# -*- coding: utf-8 -*-
"""알리고_문자를_위한_이미지/텍스트_추출_스크립트_v4

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1guarrVFnUN17EvEQNIcwmmZt1uY7Bwab

0. 왼쪽의 폴더 모양 아이콘 클릭하세요. 마우스 왼쪽 클릭해서 '새 폴더'클릭 - 폴더 이름은 'pdf'로 변경해주세요. 그 폴더에 pdf 파일들 전부 끌어 넣으세요.

1. 프로그램 설치
"""

!apt-get -y install -qq tesseract-ocr tesseract-ocr-kor
!pip -q install pymupdf pillow pytesseract google-api-python-client google-auth-httplib2 google-auth-oauthlib opencv-python-headless

"""2. PDF -> JPG"""

import os, re
import numpy as np
import cv2
import fitz
from PIL import Image
import pytesseract
from pytesseract import Output

PDF_DIR = "/content/pdf"
JPG_DIR = "/content/jpg"
os.makedirs(JPG_DIR, exist_ok=True)

ZOOM = 2.6
ROW_KEYWORDS = ["comment", "코멘트"]
OCR_LANGS = "eng+kor"
OCR_MIN_CONF = 50
OCR_PSM = 6
MIN_HLINE_RATIO = 0.55
LEFT_BAND_RATIO = 0.4
ROW_PAD_UP_PT = 2
ROW_PAD_DOWN_PT = 2

def _norm_token(s: str) -> str:
    return re.sub(r"[^0-9a-zA-Z가-힣]", "", (s or "").lower())

def _opencv_horizontal_lines(gray: np.ndarray, min_len_ratio: float) -> list[int]:
    thr = cv2.threshold(gray, 0, 255, cv2.THRESH_BINARY+cv2.THRESH_OTSU)[1]
    binimg = 255 - thr if np.mean(thr) > 128 else thr
    W = gray.shape[1]
    k = max(1, W // 60)
    kernel = cv2.getStructuringElement(cv2.MORPH_RECT, (k, 1))
    morph = cv2.morphologyEx(binimg, cv2.MORPH_OPEN, kernel, iterations=1)
    contours, _ = cv2.findContours(morph, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)
    ys = []
    for c in contours:
        x, y, w, h = cv2.boundingRect(c)
        if w >= int(W * min_len_ratio) and h <= 4:
            ys.append(y)
    return sorted(set(ys))

def _ocr_has_keyword(pil_img: Image.Image) -> bool:
    data = pytesseract.image_to_data(
        pil_img, lang=OCR_LANGS, config=f"--psm {OCR_PSM}", output_type=Output.DICT
    )
    for i in range(len(data["text"])):
        txt = _norm_token(data["text"][i])
        if not txt:
            continue
        try:
            conf = float(data["conf"][i])
        except:
            conf = 0
        if conf < OCR_MIN_CONF:
            continue
        for kw in ROW_KEYWORDS:
            if _norm_token(kw) in txt:
                return True
    return False

def find_comment_row_band(page: fitz.Page):
    mat = fitz.Matrix(ZOOM, ZOOM)
    pix = page.get_pixmap(matrix=mat, alpha=False)
    Wpx, Hpx = pix.width, pix.height
    img = Image.frombytes("RGB", (Wpx, Hpx), pix.samples)
    gray = cv2.cvtColor(np.array(img), cv2.COLOR_RGB2GRAY)

    y_lines = _opencv_horizontal_lines(gray, MIN_HLINE_RATIO)
    if len(y_lines) < 2:
        return None
    y_lines = sorted(y_lines)

    left_w = int(Wpx * LEFT_BAND_RATIO)
    for i in range(len(y_lines)-1):
        top_px, bot_px = y_lines[i], y_lines[i+1]
        if bot_px - top_px < 8:
            continue
        crop = img.crop((0, top_px, left_w, bot_px))
        if _ocr_has_keyword(crop):
            top_pt = max(page.rect.y0, (top_px / ZOOM) - ROW_PAD_UP_PT)
            bot_pt = min(page.rect.y1, (bot_px / ZOOM) + ROW_PAD_DOWN_PT)
            return (top_pt, bot_pt)
    return None

def render_page_cut_band(page: fitz.Page, band, zoom: float = ZOOM):
    mat = fitz.Matrix(zoom, zoom)
    pix = page.get_pixmap(matrix=mat, alpha=False)
    img = Image.frombytes("RGB", [pix.width, pix.height], pix.samples)

    if band:
        px_per_pt = zoom
        top_px = int(max(0, round(band[0] * px_per_pt)))
        bot_px = int(min(img.height, round(band[1] * px_per_pt)))

        # 위쪽 + 아래쪽
        upper = img.crop((0, 0, img.width, top_px))
        lower = img.crop((0, bot_px, img.width, img.height))

        # 두 부분 합치기
        new_h = upper.height + lower.height
        new_img = Image.new("RGB", (img.width, new_h), (255,255,255))
        new_img.paste(upper, (0, 0))
        new_img.paste(lower, (0, upper.height))
        return new_img

    return img

for pdf_file in os.listdir(PDF_DIR):
    if not pdf_file.lower().endswith(".pdf"):
        continue
    pdf_path = os.path.join(PDF_DIR, pdf_file)
    doc = fitz.open(pdf_path)
    if len(doc) == 0:
        continue
    page = doc[0]

    band = find_comment_row_band(page)
    final_img = render_page_cut_band(page, band)

    base = os.path.splitext(pdf_file)[0]
    final_img.save(os.path.join(JPG_DIR, f"{base}_학부모.jpg"), "JPEG", quality=95)

    doc.close()

print("✅ 변환 완료!")

"""3. JPG 폴더 저장 - 저장된 폴더는 zip 압축 상태 입니다. 압축을 풀면 jpg 사진을 사용할 수 있습니다."""

import shutil
from google.colab import files

# jpg 폴더를 zip으로 압축
shutil.make_archive("/content/jpg_folder", 'zip', JPG_DIR)

# 로컬 다운로드
files.download("/content/jpg_folder.zip")

"""**4. 텍스트 추출**
이 부분 수정




"""

import os, re
import fitz  # PyMuPDF

# ==== 경로 ====
PDF_DIR = "/content/pdf"
TXT_DIR = "/content/txt"
os.makedirs(TXT_DIR, exist_ok=True)

# ==== 옵션 ====
ROW_KEYWORDS = ["comment", "코멘트"]

def _norm_token(s: str) -> str:
    return re.sub(r"[^0-9a-zA-Z가-힣]", "", (s or "").lower())

def extract_comment_text(page: fitz.Page) -> str:
    """
    텍스트 PDF에서 Comment 칸 옆의 전체 텍스트 추출
    """
    blocks = page.get_text("blocks")
    drawings = page.get_drawings()

    # 1) Comment 라벨 텍스트 블록 찾기
    label_rect = None
    for b in blocks:
        x0, y0, x1, y1, txt, *_ = b
        norm = _norm_token(txt)
        if any(_norm_token(kw) in norm for kw in ROW_KEYWORDS):
            label_rect = fitz.Rect(x0, y0, x1, y1)
            break
    if not label_rect:
        return "코멘트 없음"

    # 2) 도형(사각형) 중 Comment 블록을 포함하는 칸 찾기
    comment_cell = None
    for d in drawings:
        if "rect" in d:  # 사각형 도형
            r = fitz.Rect(d["rect"])
            if r.contains(label_rect):  # Comment 텍스트가 포함된 칸
                comment_cell = r
                break
    if not comment_cell:
        return "코멘트 없음"

    # 3) Comment 셀 오른쪽 전체 영역을 코멘트 영역으로 설정
    comment_area = fitz.Rect(comment_cell.x1, comment_cell.y0, page.rect.x1, comment_cell.y1)

    # 4) 그 영역 텍스트 추출
    text = page.get_text("text", clip=comment_area)
    text = re.sub(r"\s+", " ", text).strip()
    return text if text else "숙제를 해오지 않았습니다."


# ==== 실행 ====
results = {}

for pdf_file in os.listdir(PDF_DIR):
    if not pdf_file.lower().endswith(".pdf"):
        continue

    base = os.path.splitext(pdf_file)[0]
    m = re.match(r".*_(TEST|HW)_(.+)", base)
    if not m:
        continue
    kind, name = m.groups()

    doc = fitz.open(os.path.join(PDF_DIR, pdf_file))
    if len(doc) == 0:
        continue

    # 모든 페이지 확인
    comment_text = "코멘트 없음"
    for page in doc:
        comment_text = extract_comment_text(page)
        if comment_text != "코멘트 없음":
            break

    if name not in results:
        results[name] = {}
    results[name][kind] = comment_text

    doc.close()

# ==== txt 저장 ====
for name, comments in results.items():
    txt_path = os.path.join(TXT_DIR, f"{name}.txt")
    with open(txt_path, "w", encoding="utf-8") as f:
        f.write("안녕하세요. 중계 매시브학원 국어 이동인T입니다.\n\n")
        f.write("2025. 08. 24. TEST 채점 결과 발송드립니다.\n\n")
        f.write("--- TEST 코멘트 ---\n")
        f.write(comments.get("TEST", "코멘트 없음") + "\n\n")
        f.write("--- HW 코멘트 ---\n")
        f.write(comments.get("HW", "숙제를 해오지 않았습니다") + "\n")

print("✅ 모든 학생 코멘트가 txt로 저장되었습니다.")

"""5. txt 폴더 저장 - 마찬가지로 zip 형태로 저장됩니다. 압축을 풀면 이름으로 저장된 txt 파일을 확인할 수 있습니다. 곧바로 복사해서 알리고로 쏘면 됩니다."""

import shutil
from google.colab import files

# txt 폴더를 zip으로 압축
shutil.make_archive("/content/txt_folder", 'zip', TXT_DIR)

# 로컬 다운로드
files.download("/content/txt_folder.zip")